# ElasticSearch Essential

#### ✓ ElasticSearch 란

루씬(Lucene) 기반의 오픈소스 검색 엔진(based java) Json 기반의 문서를 저장/검색 및 분석 작업 가능

- 특징
  - 실시간이라고 생각될 만큼 색인된 **데이터가 빠르게 검색**됨 -> refresh_interval (기본값 1초)
  - **고가용성**을 위한 클러스터 구성 : 한 대 이상의 노드로 클러스터를 구성하여 높은 수준의 안정성/ 부하 분산
  - **동적 스키마 생성** : 입력될 데이터들에 대해 미리 스키마를 정의하지 않아도 동적으로 스키마 생성
  - **Rest API 기반의 인터페이스** : 사용을 위한 특별한 클라이언트가 필요 없음

#### ✓ 클러스터 란

여러 대의 노드들이 각자의 역할을 바탕으로 연결되어 하나의 시스템처럼 동작 ->  **어떤 노드에 어떤 요청을 해도 동일한 응답을 줍니다.**

#### ✓ 노드 란

<img width="610" alt="clusterType" src="https://github.com/HYGill/kotlin_project/assets/47243329/f2dc3007-5eee-4d6f-8b86-e7f6de8df485">

- **마스터 노드** : 클러스터 상태 관리 및 메타데이터 관리
  -> 마스터 후보 노드 : 마스터 노드에 문제가 생겼을 때 마스터 노드가 될 수 있는 노드
- **데이터 노드** : 문서 색인 및 검색 요청 처리
- **코디네이팅 노드** : 검색 요청 처리
- **인제스트 노트** : 색인되는 문서의 데이터 전처리(문서가 저장되기전에 수정)

#### ✓ 인덱스, 샤드, 매핑의 정의

| ElasticSearch | RDBMS    |
| ------------- | -------- |
| Index         | Database |
| Mapping       | Schema   |
| Document      | Row      |

- **인덱스** : 문서가 저장되는 논리적인 공간. Index를 설계 하는 것이 ES를 사용하기 위해 고려해야하는 첫 단계

  | 케이스          | 장점                                            | 단점                                          |
  | --------------- | ----------------------------------------------- | --------------------------------------------- |
  | 하나의 인덱스   | 관리해야 할 인덱스의 수가 적어 관리 리소스 절감 | 쿼리와 문서 구조가 복잡                       |
  | 여러개의 인덱스 | 각각의 경우에 최적화된 쿼리와 문서 구조 사용    | 관리해야 할 인덱스 수가 많아 관리 리소스 발생 |

- **샤드** : 인덱스에 색인되는 문서가 저장되는 공간. 하나의 인덱스는 하나 이상의 샤드. index를 만들때 샤드 설정 후 바꿀 수 없음. 레플리카는 증가 가능

  - 프라이머리 샤드 : 문서가 저장되는 원본 샤드, 색인과 검색 성능에 모두 영향을 줌
  - 레플리카 샤드 : 프라이머리 샤드의 복제 샤드, 검색 성능에 영향을 줌. 프라이머리 샤드에 문제가 생기면 레플리카 샤드가 프라이머리 샤드로 승격
  - 샤드 라우팅 : 문서가 저장되는 방법. 샤드의 개수가 바뀐다면 문서가 저장되는 규칙이 완전히 바뀌게 되어 변경 불가. 
    Routing Rule = (문서의 ID)%(샤드의 개수)
    Index Template로 인덱스 생성 시의 샤드 개수를 미리 설정할 수 있음

- **매핑** : 문서의 구조를 나타내는 정보. ES는 스키마리스가 아니라 미리 정의하지 않아도 되는 것 

  - 동적 매핑 : 처음 색인되는 문서를 바탕으로 매핑 정보를 ES가 동적으로 생성. 처음 문서를 바탕으로 자동으로 생성
  - 정적 매핑 : 문서의 매핑 정보를 미리 정의
    문서의 필드들이 가지는 값에 따라 타입을 정의해 둘 필요가 있어나 불필요한 색인이 발생하지 않게 하기 위해 필요

------

#### ✓ 색인(Indexing) 과정 이해하기

: 문서를 분석하고 저장하는 과정. 색인은 프라이머리 샤드(CPU 제일 많이 사용)

- CPU가 남는다. 더 처리 가능할것같은데 ? -> 샤드의 수를 늘린다.
- CPU를 높게 쓴다 -> 스케일 업
- 색인 성능에 문제가 있다면 클러스터 로서의 이점을 살리고 있는지 먼저 살피기
  - 많은 노드들이 색인에 참여하는지, 색인에 참여한 노드들은 CPU를 잘 쓰고있는지(적게 쓰면 프라이머리 샤드를 더 배치해서 CPU를 더 끌어쓴다)
  - 샤드 배치 전략 구상하기 : https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html



#### ✓ 검색 과정 이해하기

- 검색 과정 : 검색어 분석 -> inverted index 검색 -> 검색 결과 표시
  - inverted index : 문자열을 분석한 결과를 저장하고 있는 구조체
  - 애널라이저(Analyzer) : 문자열을 분석해서 inverted index 구성을 위한 토큰을 만들어 내는 과정
  - 검색 요청은 프라이머리 샤드와 레플리카 샤드 모두가 처리 가능
  - 검색 성능에 문제가 있다면 클러스터 로서의 이점을 살리고 있는지를 먼저 살피기
    - 데이터 노드를 올리면서 레플리카 샤드도 같이 올려야 배치가 잘 된다.

#### ✓ Text / Keyword 필드 타입 이해하기

- 공통점 : **문자열**을 나타냄
- 차이점 : Text 타입은 **전문 검색(Full-text-search)**을 위해 토큰이 생성 되지만, Keyword 타입은 **Exact Matching(정확성)**을 위해 토큰이 생성됩니다.
  - I am a boy가 I/am/a/boy 로 모두 검색되는 것이 Text 타입
  - I am a boy 문자 그대로 토큰 생성이 Keyword 타입 -> 색인 속도 빠름
- 문자열의 특성에 따라 text와 keyword를 정적 매핑 해주면 성능에 도움다. 
  - 동적 매핑은 text/keyword 둘다 생성이 되는데 정적은 둘 중 필요한것만 생성 가능하기때문
- Text로 정의되면 좋을 필드 : 주소/ 이름/ 물품 상세 정보/ user_agent(Mozilla ..)
- keyword로 정의되면 좋을 필드 : 성별/ 물품 카테고리/ method(GET/POST ..)

------

#### ✓ ElasticSearch 모니터링

cat API(Compact and Aligned Text) : 클러스터 정보를 사람이 읽기 편한 형태로 출력하기 위한 용도로 만들어진 API

?v : 항목을 나타내려면 v있어야함 (ex _cat/health?v)

- **_cat/health** : 클러스터 상태 확인 시 사용

  - ES 클러스터의 전반적인 상태를 확인할 수 있음
  - relo : 재배치 샤드. 데이터 노드를 클러스터에 추가하면 샤드가 옮겨지는데 그러한 것을 나타냄
  - Unassign : 노드에 샤드가 배치되지 않은것
  - status

  | 상태   | 의미                                                         |
  | ------ | ------------------------------------------------------------ |
  | Green  | 프라이머리 샤드, 레플리카 샤드 모두 정상적으로 각 노드에 배치되어 동작 |
  | Yellow | 프라이머리 샤드는 정상적으로 동작. 일부 레플리카 샤드가 정상적으로 배치 안됨. 색인 성능에는 이상 없지만 검색 성능에 영향을 줌 |
  | Red    | 일부 프라이머리 샤드와 레플리카 샤드가 정상적으로 배치되지 않은 상태. 검색/색인 둘다 영향이 가며, 문서 유실 발생 가능 |

  

- **_cat/nodes** : 노드들의 전반적인 상태 확인. 노드들의 디스크 사용량 확인, 노드 역할 수행 확인, 메모리 사용량 확인 등등

  - master에 *이 붙어있음
  - ?help를 통해 필요한 정보 내용을 찾을 수 있음
  - (Header) ?h=ip,heap.percent, ....
    ex) curl -X GET "~~/_cat/indices" | grep -i red

  

- **_cat/indices** : 인덱스의 상태 확인. 인덱스의 샤드 갯수 확인 및 이상 상태인 인덱스 확인

  - Store.size : 프라이머리/레플리카 샤드 전체 데이터 크기
  - Pro.store.size : 프라이머리 크기
  - cat health 에서 본 status 상태와 동일. 즉 클러스터 상태가 인덱스의 상태. 1개 이상의 인덱스가 yellow면 클러스터도 yellow

  

- **_cat/shards** : 샤드의 상태 확인. 이상 상태인 샤드를 확인하고 이상상태를 확인한다.

  - (Header) ?h=index,shard,docs,unassigned.reason, ...
    ex) curl -X GET "~~/_cat/shards?h=st,unassigned.reason.." | grep -iv started

☞ 즉, health를 통해 클러스터의 문제를 인지하고, indices를 통해 문제가 있는 인덱스 이름을 파악하고, shards에 문제 인덱스를 검색하여 이유를 안다

#### ✓ 주요 모니터링 지표

- **알람 지표**
  - CPU Usage : 노드가 CPU를 얼마나 많이 사용하고 있는가
    50% 이상
  - Disk Usage(Disk Free Space) : 노드가 얼마나 많은 문서를 저장하고 있는가
    70% 이상
  - Load(부하) : 노드가 얼마나 많은 CPU와 디스크 연산을 처리하고 있는가. 노드가 처리하고 있는 프로세스 개수
    CPU 개수에 따라 상이. 2개라면 2이상(CPU 갯수보다 프로세스가 많으면 안됨)
  - JVM Heap : 노드의 JVM이 얼마나 많은 메모리를 사용하는가
    85% 이상
  - Thread : 처리량을 넘어서는 색인/검색 요청이 있는가 -> 노드가 처리량을 넘어서는 것
    Rejected Threads가 1 이상 -> 있어서는 안되니까
- **문제 원인 지표**
  - Memory Usage : 노드에 설치되어 있는 물리적인 메모리 사용량
    -> GC가 너무 많이 나서 JVM Heap을 키울때 물리적인 메모리를 우선 봄
  - GC Rate : 노드에서 발생하는 GC 발생 주기
  - GC Duration : GC 소요 시간
  - Disk I/O : 노드에서 발생하는 디스크 연산의 지연 시간
    -> 성능에 문제가 있다면 더 빠른 Disk로 교체해야함
  - Latency : 노드에서 색인 및 검색에 소요되는 시간
    -> 색인이 느리면 latency를 확인. 첫번째 관문 이 이후로 GC인가 Disk인가 등등 의심해본다
  - Rate : 노드에서 색인 및 검색 요청이 인입되는 양

